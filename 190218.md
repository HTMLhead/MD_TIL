# 190218-

---

## 해설 (키워드 위주)

1. closure 와 스코프관계를 설명해보세요.

함수를 반환하면 변수에 접근이 불가능하지만, 계속 접근할 수 있도록 해주는 것. 경험에 의한 것을 이야기하는 것이 좋음. closure와 같은 현상을 이용해서 module패턴을 사용해서 public과 private와 같은 것을 사용할 수 있음. 기본적으로 함수 내부에 있는 값은 private임.

2. prototype 의 동작방식에 대해서 설명해보세요.

광범위함. 자바스크립트 전체 객체의 구조가 prototype으로 연결되어 있음. 최상위 object까지. prorotype은 메모리 효율성의 장점을 가지고 있음. 어떤 장점이 있는지 얘기하면 좋음. 경험이 있어야 좋다! 상속을 흉내낼 수 있음. es6 class 는 결국 prototype을 사용함.

3. event delegation이 무엇인가요? 

div > p > span span에 eventlistener를 걸기보단 부모에 eventListener를 거는 것이 좋음. span이 여러개라고 치면, 여러개의 이벤트를 등록해야 하는데, 부모에 걸면 하나만 걸면 되니까. 브라우저가 이벤트를 볼 때, 이 3개의 태그가 모두 클릭되었다고 판단함. 이벤트 실행 순서는 1span, 2.p, 3. div 에서 이벤트를 실행함. 버블링과 캡쳐링이 왜나왔고, 그것을 통해서 어떻게 이벤트를 위임할 수 있는지 알 수 있도록 해야함. **기본중에 기본**

4. 비동기가 연속되어 있는 경우에 어떤방식으로 처리하세요? 

비동기는 해도해도 어려울것임.
setInterval의 단점은?
promise와 async, await을 알아두면 좋다. **promise가 가장 중요함** 
이런건 경험을 늘리는 것이 가장 좋음. 이러한 상황을 하나 만들어서 적용해보자.

5. 본인이 하는 JavaScript 디버깅방법에 대해서 설명해보세요. 

소스코드의 수정없이 디버깅을 할 수 있도록 해야한다. callstack을 이용해서 stack을 추정해서 값이 어떻게 바뀌었는지 알아보는 것이 중요함. source탭을 잘 알아야 함. chrome에 업데이트 되는 것이 있으면 보는것이 좋은데 번역이 아주 잘 되어있다고 하니 한번 보도록 하자.

6. 계속 돌아가는 캐로셀UI의 구현 원리에 대해서 설명해보세요.

생략(node를 뺏다가 넣었다가)라이브러리를 사용할 때 돔 구조가 어떻게 변하는지 찾아보는 것이 좋음.

7. getElmentById , getElementsByClassName 메서드 중 어떤 것이 더 빠를까요? 그 이유는? 

id는 id를 찾으면 바로 멈추고, className은 끝까지 찾기 떄문에 id로 찾는 것이 더 빠르다. 그래도 첫번째 발견되는 노드를 딱 찾고 멈추기 떄문에 빠름. id는 하나 이상을 만들 수도 있음.

8. NodeList의 결과를 Array에 있는 reduce메서드를 사용할 수 있나요? 방법은? 

array.from사용, spread operator등등

9. Event 객체에 대해서 설명해보세요

브라우저가 만들어주는 객체로써, window에 존재하긴 합니다만, 그렇게 접근하면 안됨.

10. Ajax요청시 크로스 도메인 문제를 어떻게 해결할 수 있나요? 

ajax이후에 크로스도메인 문제를 이해하는 것이 좋다. 회사에서 서비스를 할 때에 자식 도메인을 사용하는 경우가 있는데 부모 도메인에서 자식 도메인에 접근하는 것이 거부되어있음. json.p(참고로) cors(꼭 알아야함)를 사용할 수 있는데, 보안과 관련되어 있음. 화이트리스트 등을 이용해서 데이터를 가지고 올 수 있게 할 수 있음. cors는 굉장히어려움. header메서드의 option을 이용해서 preflight를 사용.(?)어렵다~ 이말이야

11. iteration protocol에 대해서 설명해보세요.

symbol.iterator로 객체를 하나 만들면 까먹지 않을 수 있음. native 내부에 iterator protocol은 next메서드를 사용해서 탐색하는 방법, iterable protocol 프로퍼티를 이용한 방법
-함수형 프로그래밍의 지연프로그래밍에 대해서 공부하면 좋음.

12. script 태그안에 defer나, async 속성에 대해서 설명해보세요.

헤더태그내에두면 
defer : 
async : 병렬로 서로 js다운받으면서 동시에 dom의 파싱을 막지 않음.
이미지 검색을 해서 찾아보면 좋음. 다시한번 돔 트리를 만드는것, script가 어떤 상황에서 돔을 블럭하는지, 이것이 초기 로딩 속도에 어떠한 영향을 주는지 공부해 볼 것.

13. 웹사이트의 초기 로딩속도를 더 빠르게 하기 위해서 무엇을 해야 할까요? 

script태그의 defer와 async를 사용하면 됨. 등등
파일을 여러개로 나눈 것을 하나로 묶어서 보냄. http request수를 줄이면 됨.
minify(공백을 지워줌), 난독화(함수 이름을 한글자로 바꾸어주는것) 도구를 사용해서 바꿀 수 있음.
http tool을 사용하면 좋은점: 요청을 할 때, 병렬로 처리할 수 있는 요청 수를 늘릴 수 있음.(성능 관련된 요소의 개선이 대부분)

14. SET과 Array 자료구조의 차이점은 무엇인가요?

데이터 중복 거를 수 있음. 객체를 사용할 것이면 특별한 이유가 아니면 map배열이면 set을 최대한 사용할 수 있도록 hashtable구조의 set 자료구조에 대해서 공부하는 것이 좋음.

15. 커링으로 동작하는 코드를 간단하게 보여주세요.

함수를 반환하는 함수를 한줄로 표현할 수 있어야 함.
function 의 bind가 이미 커링임 함수를 반환하는 함수를 반환하는 함수.
어떤 값을 들고다니다가 추가적으로 값을 추가해서 완성시키겠다 => partcial aplication-부분부분의 합.

16. 최근 가장 깊게 공부하고 있는 부분은 무엇인가요?  그 부분에 대해서 간단하게 설명해보세요.

하나를 깊게 공부하는 모습과 습관이 무척 중요함.

17. 브라우저 호환성 이슈가 있는 최신의 native method를 어떻게 실제 서비스에서 사용할 수 있나요?

아마존을 만들었다면 internetExplorer, edge, safari, opera, firefox, 등을 사용해서 모두 띄워볼 것. 브라우저 호환성에 대해서 생각해보아야 함. transfiling, babel

## fetch API(과제리뷰)  &  네트워크 (세션과 쿠키)

* post요청

id, password로 로그인할때, 댓글을 달 때 주로 post요청이 사용됨.

* **content-type**

여러가지 데이터의 타입으로 보낼 수 있다. 한가지 대표적인 예로 json데이터가 있음(content-type의 어플리케이션이 제이슨) 서버에서는 content-type을 먼저 해석함.**무척 중요한 기본**
content-type에 따라 분석하는 방법이 나누어짐

* url routing

모든 리소스의 자원은 url이다. 
이것이 key값임. 그리고 그 url을 기준으로 파싱을함. `user/blabla` 를 맵핑해서 보관해둠. url을 기준으로 파싱을 하기 시작.

* response

서버가 요청한 객체에 바로 응답을 주어서 브라우저가 대기하고 있다가 바로 받음. 브라우저에는 네트워크 모듈이 존재하고. api룰 기반으로 사용할 수 있게 해준다. 

* **status 200, 302, 404, 501**

브라우저는 404면 오류라고 판단함. 그래서 status가 404면 오류띄우고 아무것도 안함.
예쁘게 해결하려면 에러처리를 해주어야함. fetch를 사용했을 때, catch를 사용하여 하는게 대표적

* error 처리

promise에서 에러처리를 어떻게 하는지 공부해야함.
catch를 통해서 네트워크 장애가 생겼을 때, 오류상황을 정확히 주면 줄수록 좋음. error는 비동기적인 처리기 때문에 어려울 수 있음. 
-fetch api error handling(if 어쩌구를 했는데 그게 알맞지 않은 상황이라면 new error 를 만들어서 catch로 보내는 방법이 있다.)

1. promise 패턴에서 어떻게 catch로 가는가? 

promise객체를 직접 만들어 보는것이 좋음.
그게쉽다? generator로 async, await를 만들어보기.
그것도 쉽다면 transfiling babel같은 것을 만들어 보자.

network탭에서 헤더값을 자주 보고 이해하는 것이 좋다. 
실무에서 form을 어떻게 보낼까? 
-form.submit();을하면 전체의 화면이 새로고침 된다. 하지만 ajax로 form을 전송한다면? 

form데이터 객체를 이용해서 서버에 똑같이 데이터로 보낼 수 있음.

2. cookie

http header내부에 cookie가 존재함. 서버에서는 id와 password를 기록하고 있음. 서버가 두대면 서로 그 기록을 쉐어하기도 함.
cookie에 그 기록들이 담아져서 이동됨. 브라우저 내부의 쿠키에서 그것을 가지고 다님.
http request를 하면 cookie값이 왔다갔다함. 그 정보를 가지고 기록하고 있다가 서로 주거니받거니 할 수 있음. 
공개키, 개인키 정도에 대해서는 알아야 함.
구간에 대한 암호화는 https를 사용하면 됨. https는 구간에 대한 값을 통째로 암호화시킴.
세션값에 보통 userID를 넣어주는데, 그것을 가지고 request가 오면 어떤 사용자 요청인지 알 수 있고, 화면에 보여줄 수 있고, setCookie의 코드를 찾아보면 이해하기 쉬움.
chrome에 application탭에 cookie를 찾아볼것 

세션 아이디를 만들어서 정보교환을 하는 것이 좋음. 서버 자신이 기억을 하는 것이 맞음. 
stateless의 인증 session을 서버에서 기록하지 않는 방법. 이제는 SinglePageApplication인데, 이제 api만 요청만 해서 받음. 서버는 json데이터만 줌. 유저에게 자원을 주어야하는지 안주어야하는지만 확인에서 줌.
session에는 사용자의 정보를 저장하지 않지만 token에는 정보를 저장함. 서버는 그 정보를 가지고 유효한지만 확인하고 응답을 함. 서버에서는 그 토큰을 기억하지 않음.
api를 요청할때 token을 제출함.
session아이디를 만들어주고 그걸 쿠키에 담아서 이동하는 것. 쿠키에서 만드는게 아님
토큰은 서버에서 만듬. 그리고 개인키를 가지고 있음. 그 개인키를 가지고 있어아먄 인증이 됨. 토큰 또한 문자열임. 토큰의 유효기간을 매우 짧게 하면 보안상아주 좋음.

* 정리

서버와 클라이언트간의 데이터를 주고받을 때, 세션아이디가 어떻게 생겼는지 검색해보는 것도 좋음.
세션아이디는 쿠키에 저장되어 이동됨. 로그아웃 할 때, 서버로가서 그 키 세션아이디를 제거해줌.
누군가 가로채서 재사용한다~ 같은 것은 예상할 수 있어야 함.