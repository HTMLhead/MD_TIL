# Vertual Dom이 뭡니까? 이게 뭐가 좋습니까?

---

![img](https://velopert.com/wp-content/uploads/2017/03/wvbwscn7oadykroobdd3.png)

이 그림을 인용해서 우선 DOM tree가 어떻게 동작하는지 알아보자.

1. DOM Tree 생성
   브라우저가 HTML코드를 전달받으면, 그것을 동해서 `브라우저의 랜더엔진`이 노드로 이루어진 DOM Tree를 그린다.
2. Render Tree 생성
   그리고, 외부 CSS 파일과 각 엘리먼트의 inline 스타일을 파싱한다. 스타일 정보를 사용하여 DOM트리 마다의 새로운 트리를 만들어준다.
3. Render Tree내부?
   각각의 Tree들은 attach라는 메서드를 가지고 있는데, 이 메서드는 스타일 정보를 계산해서 객체형태로 반환해준다. 이 과정은 동기적이다.돔트리에 새로운 노드가 추가되면 이 attach메서드가 실행된다고 한다. 랜더트리를 만드는 과정에서는 각 요소들의 스타일이 계산되고 이 과정에서 다른 돔들의 스타일 속성들을 참조한다.
4. layout
   랜더 트리가 다 만들어 지고 나면, 레이아웃 과정을 거친다. 각 노드들은 스크린 좌표가 주어지고, 정확히 어디에 나타나야 하는지 좌표가 주어진다고 한다.
5. painting
   각요소들에 색을 입히는 작업이다. 각 노드마다의 paint라는 메서드가 있는데, 이것을 실행함으로써 색깔을 입히게 되는것이다. 이렇게 해서 우리가 원하는 화면이 나오게 된다.

자 그럼 DOM에 변확가 생기면 어떻게될까? 랜더 트리를 재생성하고, (모든 요소들의 스타일이 다시 계산되고) 레이아웃을 만들고 페인팅을 하는 과정이 또 다시 반복된다.
이 얼마나 비효율적인가?

그런 것을 방지하기 위해서 vertual dom 이 사용된다고 생각한다. vertual dom 은 변화가 일어나면 오프라인 돔 트리에 변화된 사항을 적용시키고, 모든것이 변경되었을 때 딱 한번 실제 돔에 작업물을 전달해주는 기능을 한다. Dom Tree를 만드는 것만 웹브라우저가 하고, 나머지의 기능들을 Vertual DOM이 따로 해주는 것이다. 변화가 있는 부분만, 자동으로.
또한 컴포넌트가 DOM 조작 요청을 할 때 다른 컴포넌트들과 상호작용을 하지 않아도 되고, 특정 DOM 을 조작할 것 이라던지, 이미 조작했다던지에 대한 정보를 공유 할 필요가 없다. 각 변화들의 동기화 작업을 거치지 않아도 된다는 뜻이다.